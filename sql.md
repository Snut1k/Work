# SQL

# 1.Простые запросы
## SELECT (1.1)
Конструкция Select
~~~
Select * From products
~~~
где * - это все столбцы таблицы
## Where (1.2)
Where - оператор для отбора по критерию. 
~~~
Select name, price from products where price >= 10000
~~~
Выбираем только name и price из таблицы, . Доп условие что price < 3000

Можно указать наоборот, чтобы критерий НЕ был равен, для этого нужно использовать !=

Для сравнения тексовых полей необходимо использовать кавычки ''
~~~
Select * From orders Where status != 'cancelled'
~~~
Если имеется множество условий их можно написать через OR,
~~~
Select * From orders 
where status = 'cancelled' OR status = 'returned'
~~~
 но это будет громоздко, поэтому будем использовать оператор in
~~~
Select * From orders where status in( 'cancelled', 'returned')
~~~
результат запроса: все записи где статус равен cancelled и returned 

| id | user_id | products_count | sum   | status    |

+----+---------+----------------+-------+-----------+

| 2  | 18      | 1              | 200   | cancelled |

| 6  | 1       | 2              | 7690  | cancelled |

| 10 | 13      | 7              | 13000 | returned 
## OR (1.3)
Оператор OR соответствует логическому ИЛИ. В данном случае результатом запроса будут все записи подходящие ИЛИ под одно ИЛИ под другое условие
~~~
Select * From orders where sum > 3000 or products_count >= 3
~~~
## AND (1.4)
And соответствует логческому И, результатом запроса будут записи удовлетворяющие сразу двум запросам 
~~~
Select * From orders where sum >= 3000 AND products_count < 3
~~~
## Between (1.5)
Between это оператор для выборки в определенном диапозоне чисел
~~~
Select * From orders where sum between 3000 and 10000 AND status = 'cancelled'
~~~
## NOT (1.6)
NOT инвертирует любой оператор
~~~
Select * from orders where not sum between 3000 and 10000 and status ="cancelled" 
~~~
В данном случае результатом будут все аписи НЕ входящие в промежуток от 3 до 10 тысяч.
И удовлеворяющие условию status ="cancelled" 

| id | user_id | products_count | sum   | status    |

+----+---------+----------------+-------+-----------+

| 3  | 45      | 3              | 800   | cancelled |

| 11 | 13      | 7              | 13000 | cancelled |

## Порядок OR и AND (1.7)
У AND приоритет выполнения перед OR.
Тоесть сначала выпоняется AND а потом OR.
~~~
Select * From team 
Where basic_languadge='python'  OR
basic languadge = 'php'  AND level ='middle' 
~~~
Логика верхнего запроса такова: нужно отправить таблицу с разработчиками php, у которых middle уровень знаний ИЛИ всех разработчиков на python
~~~
Select * From team 
Where (basic_languadge='python'  OR
basic languadge = 'php')  AND level ='middle' 
~~~
Логика нижнего запроса: ищем всех разработчиков на питоне или php И тех из них кто имеет средний уровень разработки.
Как видно из второго запроса, тут  как в математике, очередность меняется если поставить скобк, что в скобках то  выполняется первым.
# Сортировка
## Order by (1.8)
 Это сортировка запросов по одноу из полей от меньшего к большему. С начала и до конца алфавита от более ранней даты к более поздней от самой маленькой зарплаты к самой большой и т.д
 ~~~
 Select * From products order by price
 ~~~
Результат:
| id | name              | count | price |

+----+-------------------+-------+-------+

| 5  | Вентилятор        | 0     | 700   |

| 7  | Тостер            | 2     | 2500  |

| 8  | Принтер           | 4     | 3000  |

| 3  | Микроволновка     | 3     | 4000  |

| 4  | Пылесос           | 2     | 4500  |

| 1  | Стиральная машина | 5     | 10000 |

| 2  | Холодильник       | 0     | 10000 |

| 6  | Телевизор         | 7     | 31740 |
  Если добавить Desc, то сортировка произойдет в обртном направлени
~~~
Select name, price from products order by price desc
~~~
Результат:
 name              | price |

+-------------------+-------+

| Телевизор         | 31740 |

| Стиральная машина | 10000 |

| Холодильник       | 10000 |

| Пылесос           | 4500  |

| Микроволновка     | 4000  |

| Принтер           | 3000  |

| Тостер            | 2500  |

| Вентилятор        | 700   |

Также можно сортировать сразу по нескольким полям перечисляя их через запятую. Сначала база будет сортироваться по первому полю которое мы вписали, потом по второму. 

Мы можем также инвертировать отдельное поле при сортировке дописав к нему desc.

~~~
Select * From users 
where salary >= 40000 
order by salary desc, first_name
~~~
| id | first_name | last_name | birthday   | salary | job                 |

+----+------------+-----------+------------+--------
+---------------------+

| 7  | Александр  | Пузаков   | 2002-02-20 | 120000 | ведущий программист |

| 5  | Алена      | Шикова    | 1999-08-17 | 53000  | фотограф            |

| 2  | Ольга      | Антонова  | 1999-12-01 | 41000  | дизайнер            |

| 8  | Алина      | Антонова  | 2002-01-01 | 40000  | верстальщик         |

| 3  | Сергей     | Васильев  | 2002-02-20 | 40000  | младший программист |

# Ограничение выборки
## limit (1.9)
если limit 5 ; то показываются только первые 5 записей, если limit 10, 5; то НЕ показываются первые 10 и показываются следующие после этих 10 ти 5
~~~
 Select * from products order by price  limit 10,5
~~~

# 2. Добавление, изменение, удаление, данных
создание - insert;

чтение - select;

удаление - Deleate или Truncate ;

обновление - update;
# Добваление
## insert into (2.1) 
## values
isert- добавляет строкитаблицы;

orders- имя таблицы ;

id , products , sum -поля таблицы
~~~
insert into orders (id, products, sum)
values (6,3, 3000)
~~~
Числа не нужно добавлять в кавычки а текст и даты нужно.
Формат записи даты может быть другим в завсимости от используемого.
~~~
insert into products (id, name, count, price)
values
(8,'iPhone 7', 1,59990),
(9,'iPhone 8', 3, 64990),
(10,'iPhone X', 2, 79900);
~~~

## set (2.2) 
set имеет следующую конструкцию

INSERT INTO table SET field1=value1, field2=value2;
~~~
insert into users 
set id=10,first_name='Никита', last_name= 'Петров';
~~~

## update (2.3) 
update-  преднаначен для изменения полей таблицы 
~~~
Update products set name = 'iMac' where id =7;
~~~
## set (2.4) 
set - это как и какие мы изменяем поля мы изменяем поля:
~~~
Update users set salary=salary*1.1 where 
~~~


## NULL (2.5) 
NULL – это особое слово в MySQL и в отличии от "cancelled" или "new", его нужно писать без кавычек.
А чтобы сравнить значение в поле с NULL, нужно использовать не символы равенства (=) и неравенства (<> или !=),
а специальное выражение IS NULL или IS NOT NULL.
~~~
update orders set status='new' 
where status is NULL
~~~
Здесь такая же ситуация для where как и в select, можно стоавить несколько условий через  OR или AND
~~~
update orders set amount=sum*products_count 
where amount =0 or amount is null
~~~
~~~
update products set count = count + 40 where name= 'Марс' or name = 'Сникерс' 
~~~
## limit (2.6) 
Тут все также как и в select, можно задать направление исполнения комманды с помощбю desc, и задать параметры, а также установить лимит
~~~
update products set price = price*1.05 
order by price desc limit 5
~~~

## (2.7) Delete
Удаляет толбцы из таблицы. К delete применимы те же принципы что и к select, update, insert 
~~~
delete from cars 
where country = 'JP' and (power >129 or power < 79)
~~~

#


## Truncate и Delete, различия
Команда DELETE удаляет записи из таблицы, которые удовлетворяют критерию WHERE.

TRUNCATE удаляет все данные из таблицы.

TRUNCATE

TRUNCATE быстрее и использует меньше системных ресурсов, чем DELETE и практически не пишет лог транзакции.

TRUNCATE удаляет данные путем деаллокации тех страниц, которые хранят табличные данные и только эти операции деаллокации записываются в лог транзакции.

TRUNCATE удаляет все строки таблицы, но структура таблицы (столбцы, ограничения, индексы и т.д.) остается. Счетчик, который используется для уникальности новых записей обнуляется.

Нельзя использовать TRUNCATE TABLE для таблиц, связанных ограничением FOREIGN KEY.
Поскольку TRUNCATE TABLE не логируется, то и не может активировать триггер.

Откат (rollback) после TRUNCATE невозможен

TRUNCATE - команда DDL

DELETE

DELETE удаляет строки в таблицы и для каждой оставляет запись в логе транзакции.

DELETE не обнуляет счетчик уникальности.

DELETE может использоваться с выражением WHERE или без него

DELETE активирует триггеры

После DELETE возможен откат

DELETE - команда DML

